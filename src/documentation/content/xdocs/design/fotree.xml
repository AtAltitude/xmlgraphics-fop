<?xml version="1.0" standalone="no"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.1//EN"
    "http://cvs.apache.org/viewcvs.cgi/*checkout*/xml-forrest/src/resources/schema/dtd/document-v11.dtd">
<document>
  <header>
    <title>FOP Design: FO Tree</title>
    <authors>
      <person name="Keiron Liddle" email="keiron@aftexsw.com"/>
    </authors>
  </header>
  <body>
    <section id="intro">
      <title>Introduction</title>
      <p>The FO Tree is an internal hierarchical representation (java objects and properties) of the input XSL-FO document, and is created from the <link href="parsing.html">parsing</link> of that XSL-FO document.
The process of building the FO Tree corresponds to the <strong>Objectify</strong> step in the XSL-FO spec.
The FO Tree is an intermediate structure which will later be <link href="layout.html">converted into the area tree</link>.</p>
    </section>
    <section id="process">
      <title>Processing</title>
      <p>The SAX Events that are fired by the parsing process are caught by the FO Tree system.
Events for starting an element, ending an element, and text data are assembled by the FO Tree system into a set of objects that represent the input FO document.</p>
      <p>For attributes attached to an XSL-FO element, a property list mapping is used to convert the attribute into properties of the object related to the element.</p>
      <p>Elements from <link href="parsing.html#namespaces">foreign namespaces</link> that are recognized by FOP fall into the following categories:</p>
      <ul>
        <li>Pass-thru: These are placed into a DOM object, which is then passed through FOP directly to the renderer. SVG is an example.</li>
        <li>FOP Internal: These are placed into objects that can then be used by FOP. An example of this would be an element that the layout process will use to create an area. Another example would be an element that contains setup information for the renderer.</li>
      </ul>
      <p>For unrecognized namespaces, a dummy object or a generic DOM is created.</p>
      <p>While the tree building is mainly about creating the FO Tree, some FO Tree events trigger processes in other parts of FOP.
The end of a page-sequence element triggers the layout process for that page-sequence (see discussion of <link href="#recycle">Recycling</link>).
Also, the end of the XML document tells the renderer that it can finalize the output document.</p>
    </section>
    <section id="recycle">
      <title>Recycling FO Tree Memory</title>
      <p>To minimize the amount of memory used by FOP, we wish to recycle FO Tree memory as much as possible.
There are at least three possible places that FO Tree fragments could be passed to the Layout process, so that their memory can be reused:</p>
      <ul>
        <li>
          <strong>fo:block</strong> It might be tempting to start laying out pages as soon as the first fo:block object is finished. However, there are many downstream things that can affect the placement of that block on a page, such as graphics and footnotes. So, in order to maintain conformance to the XSL-FO specification, and create high-quality output, we must see more of the document.</li>
        <li>
          <strong>fo:root</strong> The other extreme is to wait until the entire document is read in before processing any of it. This essentially means that there is no memory recycling. Processing the document correctly is more important than saving memory, so this option would be used if there were no better alternative.</li>
        <li>
          <strong>fo:page-sequence</strong> The page-sequence object provides a nice clean break in the document. Content from one page-sequence will never interfere with nor affect the placement of the content of another. FOP uses this option as the optimum way to maintain compliance with the standard and to minimize memory consumption.</li>
      </ul>
    </section>
    <section id="serialize">
      <title>FO Tree Serialization</title>
      <p>This issue is implied by the requirement to process documents of arbitrary size. Unless some arbitrary limit is placed on the size of page-sequence objects, FOP must be able to serialize FO tree fragments as necessary.</p>
    </section>
    <section id="specific-elements">
      <title>Notes About Specific Elements</title>
      <section id="page-master">
        <title>page-master</title>
        <p>The first elements in a document are the elements for the page master setup.
This is usually only a small number and will be used throughout the document to create new pages.
These elements are kept as a factory to create the page and appropriate regions whenever a new page is requested by the layout.
The objects in the FO Tree that represent these elements are themselves the factory.
The root element keeps these objects as a factory for the page sequences.</p>
      </section>
      <section id="flow">
        <title>flow</title>
        <p>The elements that are in the flow of the document are a set of elements
that is needed for the layout process. Each element is important in the
creation of areas.</p>
      </section>
      <section id="other-elements">
        <title>Other Elements</title>
        <p>The remaining FO Objects are things like page-sequence, title and color-profile.
These are handled by their parent element; i.e. the root looks after the declarations and the declarations maintains a list of colour profiles.
The page-sequences are direct descendents of root.</p>
      </section>
    </section>
    <section id="implement">
      <title>Implementation Notes</title>
      <section id="fonode">
        <title>FONode</title>
        <p>The base class for all objects in the tree is FONode. The base class for
all FO Objects is FObj.</p>
        <p>The class inheritance described above only describes the nature of the
content. Every FO in FOP also has a parent, and a Vector of children. The
parent attribute (in the Java sense), in particular, is used to enforce
constraints required by the FO hierarchy.</p>
        <p>FONode, among other things, ensures that FO's have a parent and that they
may have children.</p>
        <p>Each xml element is represented by a java object. For pagination the
classes are in <code>org.apache.fop.fo.pagination.*</code>, for elements in the flow
they are in <code>org.apache.fop.fo.flow.*</code> and some others are in
<code>org.apache.fop.fo.*.</code>
        </p>
      </section>
      <section id="create-fo">
        <title>Making FO's</title>
        <p>There is a class for each element in the FO set. An object is created for
each element in the FO Tree. This object holds the properties for the FO
Object.</p>
        <p>Some validity checking is done during these steps. The user can be warned of the error and processing can continue if possible.</p>
        <p>When the object is created it is setup.
It is given its element name, the FOUserAgent - for resolving properties etc. - the logger and the attributes.
The methods <code>handleAttributes()</code> and <code>setuserAgent()</code>, common to <code>FONode</code>, are used in this process.
The object will then be given any text data or child elements.
Then the <code>end()</code> method is called.
The end method is used by a number of elements to indicate that it can do certain processing since all the children have been added.</p>
        <p>An FO maker is read from a hashmap lookup using the namespace and
element name. This maker is then used to create a new class that
represents an FO element. This is then added to the FO tree as a child
of the current parent.</p>
      </section>
      <section id="foreign">
        <title>Foreign XML</title>
        <p>For SVG, the DOM needs to be created with Batik, so an element mapping is used to read all elements in the SVG namespace and pass them into the Batik DOM.</p>
        <p>The base class for foreign XML is XMLObj. This class handles creating a
DOM Element and the setting of attributes. It also can create a DOM
Document if it is a top level element, class XMLElement.
This class must be extended for the namespace of the XML elements. For
unknown namespaces the class is UnknowXMLObj.</p>
        <p>If some special processing is needed then the top level element can extend
the XMLObj. For example the SVGElement makes the special DOM required for
batik and gets the size of the svg.</p>
        <p>Foreign XML will usually be in an fo:instream-foreign-object, the XML will
be passed to the render as a DOM where the render will be able to handle
it. Other XML from an unknwon namespace will be ignored.</p>
        <p>By using element mappings it is possible to read other XML and either</p>
        <ul>
          <li>set information on the area tree</li>
          <li>create pseudo FO Objects that create areas in the area tree</li>
          <li>create FO Objects</li>
        </ul>
      </section>
      <section id="unknown">
        <title>Unknown Elements</title>
        <p>If an element is in a known namespace but the element is unknown then an
Unknown object is created. This is mainly to provide information to the
user.
This could happen if the fo document contains an element from a different
version or the element is misspelt.</p>
      </section>
    </section>
  </body>
</document>
