/*
 * $Id$
 * Copyright (C) 2001 The Apache Software Foundation. All rights reserved.
 * For details on use and redistribution please refer to the
 * LICENSE file included with these sources.
 */

package org.apache.fop.layoutmgr;

import org.apache.fop.fo.FObj;
import org.apache.fop.fo.PropertyManager;
import org.apache.fop.layout.BorderAndPadding;
import org.apache.fop.traits.InlineProps;
import org.apache.fop.area.Area;
import org.apache.fop.area.MinOptMax;
import org.apache.fop.area.inline.InlineArea;
import org.apache.fop.area.inline.InlineParent;

import java.util.Iterator;
import java.util.ListIterator;

/**
 * LayoutManager for objects which stack children in the inline direction,
 * such as Inline or Line
 */
public class InlineStackingBPLayoutManager extends AbstractBPLayoutManager {

    /**
     * Private class to store information about a lower-level BreakPosition.
     * Note: fields are directly readable in this class
     */
    private static class WrappedPosition implements BreakPoss.Position {
        BPLayoutManager m_childLM;
        BreakPoss.Position m_childPosition;

        WrappedPosition(BPLayoutManager childLM,
			BreakPoss.Position childPosition) {
            m_childLM = childLM;
            m_childPosition = childPosition;
        }
    }

    private static class StackingIter extends PositionIterator {

	StackingIter(Iterator parentIter) {
	    super(parentIter);
	}

	protected BPLayoutManager getLM(Object nextObj) {
	    return ((WrappedPosition)nextObj).m_childLM;
	}

	protected BreakPoss.Position getPos(Object nextObj) {
	    return ((WrappedPosition)nextObj).m_childPosition;
	}

    }


    /**
     * Holds IPD of all areas which would be generated by previously
     * complete childLM since last area was generated.
     */
    private MinOptMax m_prevContentIPD = new MinOptMax(0);

    /**
     * Size of any start or end borders and padding.
     */
    private MinOptMax m_allocIPD = new MinOptMax(0);

    /**
     * Size of border and padding in BPD (ie, before and after).
     */
    private MinOptMax m_extraBPD;

    /** Holds IPD of a child BP which had no break-after flag. We don't
     * add this to m_previousIPD until we are sure that the next break
     * position can really fit.
     */
    private MinOptMax m_pendingIPD = new MinOptMax(0);

    private InlineProps m_inlineProps = null;
    private BorderAndPadding m_borderProps = null;

    private InlineParent m_inlineArea;

    private boolean m_bFirstArea;
    private BreakPoss m_prevBP;

    public InlineStackingBPLayoutManager(FObj fobj, ListIterator childLMiter) {
	super(fobj, childLMiter);
	m_bFirstArea = true;
	// Initialize inline properties (borders, padding, space)
	// initProperties();
    }

    public boolean generatesInlineAreas() {
        return true;
    }

    protected void initProperties(PropertyManager propMgr) {
	// super.initProperties(propMgr);
	System.err.println("InlineStackingBPLayoutManager.initProperties called");
        m_inlineProps = propMgr.getInlineProps();
        m_borderProps = propMgr.getBorderAndPadding();
	// Calculdate border and padding size in BPD
	int iPad = m_borderProps.getPadding(BorderAndPadding.BEFORE, false);
	iPad += m_borderProps.getBorderWidth(BorderAndPadding.BEFORE, false);
	iPad += m_borderProps.getPadding(BorderAndPadding.AFTER, false);
	iPad += m_borderProps.getBorderWidth(BorderAndPadding.AFTER, false);
	m_extraBPD = new MinOptMax(iPad);
    }

    private MinOptMax getExtraIPD(boolean bNotFirst, boolean bNotLast) {
	int iBP = m_borderProps.getPadding(BorderAndPadding.START, bNotFirst);
	iBP += m_borderProps.getBorderWidth(BorderAndPadding.START, bNotFirst);
	iBP += m_borderProps.getPadding(BorderAndPadding.END, bNotLast);
	iBP += m_borderProps.getBorderWidth(BorderAndPadding.END, bNotLast);
	return new MinOptMax(iBP);
    }

    private boolean hasLeadingFence(boolean bNotFirst) {
	int iBP = m_borderProps.getPadding(BorderAndPadding.START, bNotFirst);
	iBP += m_borderProps.getBorderWidth(BorderAndPadding.START, bNotFirst);
	return (iBP > 0);
    }
    
    private boolean hasTrailingFence(boolean bNotLast) {
	int iBP = m_borderProps.getPadding(BorderAndPadding.END, bNotLast);
	iBP += m_borderProps.getBorderWidth(BorderAndPadding.END, bNotLast);
	return (iBP > 0);
    }
    

    /** Reset position for returning next BreakPossibility. */

    public void resetPosition(BreakPoss.Position prevPos) {
	WrappedPosition wrappedPos = (WrappedPosition)prevPos;
	if (wrappedPos != null) {
	    // Back up the layout manager iterator
	    reset(wrappedPos.m_childLM, wrappedPos.m_childPosition);
	}
	else {
	    // Backup to first child layout manager
	    System.err.println("InlineStackingBPLM: resetPosition(null)");
	    super.resetPosition(prevPos);
	}
	// Do we need to reset some context like pending or prevContent?
    }


    /**
     * Return value indicating whether the next area to be generated could
     * start a new line. This should only be called in the "START" condition
     * if a previous inline BP couldn't end the line.
     * Return true if any space-start, border-start or padding-start, else
     * propagate to first child LM
     */
    public boolean canBreakBefore(LayoutContext context) {
	if (m_inlineProps.spaceStart.space.min > 0 ||
	    hasLeadingFence(false)) {
	    return true;
	}
	BPLayoutManager lm = getChildLM();
	if (lm != null) {
	    return lm.canBreakBefore(context);
	}
	else return false; // ??? NO child LM?
    }


    public BreakPoss getNextBreakPoss(LayoutContext lc,
				      BreakPoss.Position pbp) {
        // Get a break from currently active child LM
        BreakPoss bp =null;
	BPLayoutManager curLM ;
	// Handle space before
	boolean bIncludeStartSpace=false;
	LayoutContext childLC = new LayoutContext(lc);
	if (lc.isStart()) {
	    // First call to this LM in new parent "area", ie, this may
	    // not be the first area created by this inline
	    lc.getPendingSpace().addSpace(m_inlineProps.spaceStart);
	    // Check for "fence"
	    if (hasLeadingFence(!m_bFirstArea)) {
		bIncludeStartSpace=true;
		// Reset leading space sequence for child areas
		childLC.setPendingSpace(new SpaceSpecifier(false));
	    }
	    // Reset state variables
	    m_pendingIPD = new MinOptMax(0);
	    m_prevContentIPD = new MinOptMax(0);
	}
	else {
	    // Handle pending IPD: if we are called again, we assume previous
	    // break was OK
	    m_prevContentIPD.add(m_pendingIPD);
	    m_pendingIPD = new MinOptMax(0);
	}
// 	    if (m_prevChildLM != curLM && m_prevChildLM != null) {
// 		// Change child LM
// 		m_prevContentIPD.add(m_pendingIPD);
// 	    }

        while ((curLM = getChildLM()) != null) {
	    // ????
	    /* If first break for this child, set START_AREA flag */
	    if (m_prevBP == null || m_prevBP.getLayoutManager()!=curLM) {
		childLC.setFlags(LayoutContext.START_AREA);
		if (m_prevBP != null) {
		    childLC.setPendingSpace(m_prevBP.getTrailingSpace());
		}
	    }

	    if (((bp = curLM.getNextBreakPoss(childLC)) != null)) {
		// && couldEndLine(bp)) {
		break;
	    }
// 	    if (bp.isLastArea()) {
// 		// NORMALLY IT MUST BE!
// 		m_pendingIPD.add(bp.getStackingSize());
// 		m_prevBP = bp;
// 	    }
        }
        if (bp==null) {
	    setFinished(true);
            return null; // There was no childLM
            // Alternative is to return a BP with the isLast flag set
        }
        else {
	    // TODO! need to know whether this BP is in the first area for FO!
            return makeBreakPoss(bp, lc.isStart(),
				 (getChildLM() == null), lc);
        }
    }

    protected boolean couldEndLine(BreakPoss bp) {
	if (bp.canBreakAfter()) {
	    return true; // no keep, ends on break char
	}
	else if (bp.isSuppressible()) {
	    // NOTE: except at end of content for this LM!!
	    // Never break after only space chars or any other sequence
	    // of areas which would be suppressed at the end of the line.
	    return false; 
	}
	else {
	    // See if could break before next area
	    LayoutContext lc=new LayoutContext();
	    BPLayoutManager nextLM = getChildLM();
	    return (nextLM == null || 
		    nextLM.canBreakBefore(lc));
	}
    }



    protected BreakPoss makeBreakPoss(BreakPoss bp, boolean bIsFirst, 
				   boolean bIsLast, LayoutContext lc) {
        WrappedPosition inlbp =
            new WrappedPosition(bp.getLayoutManager(), bp.getPosition());
	BreakPoss myBP = new BreakPoss(this, inlbp, bp.getFlags());

        // Update dimension information for our allocation area,
	// including child areas
        // generated by previous childLM which have completed layout
        // Update pending area measure
        // This includes all previous breakinfo
	
	MinOptMax bpDim = (MinOptMax)bp.getStackingSize().clone();

        if (m_prevBP == null ||
	    m_prevBP.getLayoutManager() != bp.getLayoutManager()) {
	    /* This is first bp generated by child (in this parent area).
	     * Calculate space-start on this area in combination with any
	     * pending space-end on previously generated break possibilities.
	     * Can also have leading space if this FO has fence-preceding.
	     */
	    bpDim.add(bp.resolveLeadingSpace());
        }
        if (bp.isLastArea()) {
	    m_pendingIPD.add(bpDim);
	    // See if our area is also done
	    
        }

	// Start and end borders and padding
	bpDim.add(m_prevContentIPD);
	bpDim.add(getExtraIPD(!bIsFirst, !bIsLast));
	myBP.setStackingSize(bpDim);
	myBP.setNonStackingSize(MinOptMax.add(bp.getNonStackingSize(),
					      m_extraBPD));
        if (bIsLast) {
	    setFinished(true);  // Our last area, so indicate done
            myBP.setFlag(BreakPoss.ISLAST, true);
        }
	else {
            myBP.setFlag(BreakPoss.ISLAST, false);
	}
	myBP.setTrailingSpace((SpaceSpecifier)bp.getTrailingSpace().clone());
	myBP.getTrailingSpace().addSpace(m_inlineProps.spaceEnd);
	// If this FO doesn't have fence-start, then this value should
	// come from the lower level BP!
	myBP.setLeadingSpace(new SpaceSpecifier(false));
	m_prevBP = bp;
	return myBP;
    }



    /******
    protected BreakableText getText(BreakPoss prevBP, BreakPoss lastBP) {
    }
    *****/

    // Generate and add areas to parent area
    // Set size etc
    public void addAreas(PositionIterator parentIter) {
        // Make areas from start to end
        // Update childLM based on bpEnd
        // It might be a previous sibling of the current one!

        m_inlineArea = new InlineParent();
       
	// Note: if first, bpStart is perhaps null????
	// If we are first in parent, set ISFIRST...


	// posIter iterates over positions returned by this LM
	StackingIter childPosIter = new StackingIter(parentIter);
	BPLayoutManager childLM ;
	while  ((childLM = childPosIter.getNextChildLM())!= null) {
	    childLM.addAreas(childPosIter);
	}
	
	parentLM.addChild(m_inlineArea);
    }


//     protected Area createArea() {
//         return new InlineParent();
//     }

    public boolean addChild(Area childArea) {
	// Make sure childArea is inline area
	if (childArea instanceof InlineArea) {
	    m_inlineArea.addChild((InlineArea)childArea);
	}
	return false;
    }


}
