/*
 * $Id$
 * Copyright (C) 2001 The Apache Software Foundation. All rights reserved.
 * For details on use and redistribution please refer to the
 * LICENSE file included with these sources.
 */

package org.apache.fop.layoutmgr;

import org.apache.fop.apps.FOPException;
import org.apache.fop.fo.FObj;
import org.apache.fop.fo.properties.Constants;
import org.apache.fop.area.*;

import java.util.ArrayList;
import java.util.List;

/**
 * LayoutManager for an fo:flow object.
 * Its parent LM is the PageLayoutManager.
 * This LM is responsible for getting columns of the appropriate size
 * and filling them with block-level areas generated by its children.
 */
public class FlowLayoutManager extends BlockStackingLayoutManager {

    private static class BlockBreakPosition extends LeafPosition {
        List blockps;

        BlockBreakPosition(BPLayoutManager lm, int iBreakIndex, List bps) {
            super(lm, iBreakIndex);
            blockps = bps;
        }
    }

    /** Array of areas currently being filled stored by area class */
    private BlockParent[] currentAreas = new BlockParent[Area.CLASS_MAX];

    /**
     * This is the top level layout manager.
     * It is created by the PageSequence FO.
     */
    public FlowLayoutManager(FObj fobj) {
        super(fobj);
    }

    public boolean generateAreas() {

        ArrayList vecBreakPoss = new ArrayList();

        BreakPoss bp;
        LayoutContext childLC = new LayoutContext(0);
        while (!isFinished()) {
            if ((bp = getNextBreakPoss(childLC, null)) != null) {
                System.out.println("Flow Break: " + bp);
                vecBreakPoss.add(bp);
            }
        }

        addAreas( new BreakPossPosIter(vecBreakPoss, 0,
                                       vecBreakPoss.size()), null);
        flush();
        return false;
    }

    public BreakPoss getNextBreakPoss(LayoutContext context,
                                      Position prevLineBP) {

        BPLayoutManager curLM ; // currently active LM

        while ((curLM = getChildLM()) != null) {
            // Make break positions and return lines!
            // Set up a LayoutContext
            int bpd = 0;
            BreakPoss bp;
            ArrayList vecBreakPoss = new ArrayList();

            // Force area creation on first call
            // NOTE: normally not necessary when fully integrated!
            LayoutContext childLC = new LayoutContext(0);

            while (!curLM.isFinished()) {
                if ((bp = curLM.getNextBreakPoss(childLC, null)) != null) {
                    vecBreakPoss.add(bp);
                    // Reset stackLimit for non-first lines
                    childLC.setStackLimit(new MinOptMax(bpd));
                }
            }

System.out.println("Flow BreakPoss: " + vecBreakPoss);

            return new BreakPoss(
                     new BlockBreakPosition(curLM, 0, vecBreakPoss));
        }
        setFinished(true);
        return null;
    }

    public void addAreas(PositionIterator parentIter, LayoutContext lc) {
System.out.println("FL add: " + parentIter);
        while (parentIter.hasNext()) {
            BlockBreakPosition bbp = (BlockBreakPosition) parentIter.next();
System.out.println("FL add: " + bbp);
            bbp.getLM().addAreas( new BreakPossPosIter(bbp.blockps, 0,
                                  bbp.blockps.size()), null);
        }
        flush();
    }


    /**
     * Add child area to a the correct container, depending on its
     * area class. A Flow can fill at most one area container of any class
     * at any one time. The actual work is done by BlockStackingLM.
     */
    public boolean addChild(Area childArea) {
        return addChildToArea(childArea,
                              this.currentAreas[childArea.getAreaClass()]);
    }

    public Area getParentArea(Area childArea) {
        // Get an area from the Page
        BlockParent parentArea =
          (BlockParent) parentLM.getParentArea(childArea);
        this.currentAreas[parentArea.getAreaClass()] = parentArea;
        setCurrentArea(parentArea);
        return parentArea;
    }

}

