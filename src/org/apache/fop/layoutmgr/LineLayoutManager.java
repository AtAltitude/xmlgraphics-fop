/*
 * $Id$
 * Copyright (C) 2001 The Apache Software Foundation. All rights reserved.
 * For details on use and redistribution please refer to the
 * LICENSE file included with these sources.
 */

package org.apache.fop.layoutmgr;


import org.apache.fop.fo.FObj;
import org.apache.fop.area.Area;
import org.apache.fop.area.LineArea;
import org.apache.fop.area.MinOptMax;
import org.apache.fop.area.inline.InlineArea;
import org.apache.fop.fo.properties.VerticalAlign;

import org.apache.fop.area.inline.Word;
import org.apache.fop.area.inline.Character;

import java.util.ListIterator;
import java.util.List;
import java.util.Iterator;

/**
 * LayoutManager for lines. It builds one or more lines containing
 * inline areas generated by its sub layout managers.
 */
public class LineLayoutManager extends AbstractLayoutManager {
    /** Reference to FO whose areas it's managing or to the traits
     * of the FO.
     */
    private ListIterator fobjIter;
    private LineArea lineArea = null;
    private boolean bFirstLine;
    private LayoutManager curLM;
    private MinOptMax remainingIPD;
    // the following values must be set by the block
    // these are the dominant basline and lineheight values
    private int lineHeight;
    private int lead;
    private int follow;

    public LineLayoutManager(ListIterator fobjIter, int lh, int l, int f) {
        super(null);
        this.fobjIter = fobjIter;
        lineHeight = lh;
        lead = l;
        follow = f;
    }

    /**
     * Call child layout managers to generate content as long as they
     * generate inline areas. If a block-level generating LM is found,
     * finish any line being filled and return to the parent LM.
     */
    public void generateAreas() {
        this.bFirstLine = true;
        while (fobjIter.hasNext()) {
            FObj childFO = (FObj) fobjIter.next();
            if (childFO.generatesInlineAreas() == false) {
                // It generates blocks, pass back to parent
                // Back up one
                fobjIter.previous();
                break;
            } else { // generates inline area
                curLM = childFO.getLayoutManager();
                if (curLM != null) {
                    curLM.setParentLM(this);
                    curLM.generateAreas();
                }
            }
        }
        flush(); // Add last area to parent
    }

    /**
     * Align and position curLine and add it to parentContainer.
     * Set curLine to null.
     */
    public void flush() {
        if (lineArea != null) {
            // Adjust spacing as necessary

            verticalAlign();

            parentLM.addChild(lineArea);
            lineArea = null;
        }
    }

    private void verticalAlign() {
        int maxHeight = lineHeight;
        List inlineAreas = lineArea.getInlineAreas();

        // get smallest possible offset to before edge
        // this depends on the height of no and middle alignments
        int before = lead;
        int after = follow;
        for(Iterator iter = inlineAreas.iterator(); iter.hasNext(); ) {
            InlineArea inline = (InlineArea)iter.next();
            LayoutInfo info = inline.info;
            int al;
            int ld = inline.getHeight();
            if(info != null) {
                al = info.alignment;
                ld = info.lead;
            } else {
                al = VerticalAlign.BASELINE;
            }
            if(al == VerticalAlign.BASELINE) {
                if(ld > before) {
                    before = ld;
                }
                if(inline.getHeight() > before) {
                    before = inline.getHeight();
                }
            } else if(al == VerticalAlign.MIDDLE) {
                if(inline.getHeight() / 2  + lead / 2 > before) {
                    before = inline.getHeight() / 2 + lead / 2;
                }
                if(inline.getHeight() / 2 - lead / 2 > after) {
                    after = inline.getHeight() / 2 - lead / 2;
                }
            } else if(al == VerticalAlign.TOP) {
            } else if(al == VerticalAlign.BOTTOM) {
            }
        }

        // then align all before, no and middle alignment
        for(Iterator iter = inlineAreas.iterator(); iter.hasNext(); ) {
            InlineArea inline = (InlineArea)iter.next();
            LayoutInfo info = inline.info;
            int al;
            int ld = inline.getHeight();
            boolean bloffset = false;
            if(info != null) {
                al = info.alignment;
                ld = info.lead;
                bloffset = info.blOffset;
            } else {
                al = VerticalAlign.BASELINE;
            }
            if(al == VerticalAlign.BASELINE) {
                // the offset position for text is the baseline
                if(bloffset) {
                    inline.setOffset(before);
                } else {
                    inline.setOffset(before - ld);
                }
                if(inline.getHeight() - ld > after) {
                    after = inline.getHeight() - ld;
                }
            } else if(al == VerticalAlign.MIDDLE) {
                inline.setOffset(before - inline.getHeight() / 2 - lead / 2);
            } else if(al == VerticalAlign.TOP) {
                inline.setOffset(0);
                if(inline.getHeight() - before > after) {
                    after = inline.getHeight() - before;
                }
            } else if(al == VerticalAlign.BOTTOM) {
                if(inline.getHeight() - before > after) {
                    after = inline.getHeight() - before;
                }
            }
        }

        // after alignment depends on maximum height of before
        // and middle alignments
        for(Iterator iter = inlineAreas.iterator(); iter.hasNext(); ) {
            InlineArea inline = (InlineArea)iter.next();
            LayoutInfo info = inline.info;
            int al; 
            if(info != null) {
                al = info.alignment;
            } else {
                al = VerticalAlign.BASELINE;
            }
            if(al == VerticalAlign.BASELINE) {
            } else if(al == VerticalAlign.MIDDLE) {
            } else if(al == VerticalAlign.TOP) {
            } else if(al == VerticalAlign.BOTTOM) {
                inline.setOffset(before + after - inline.getHeight());
            }
        }
        if(before + after > maxHeight) {
            lineArea.setHeight(before + after);
        } else {
            lineArea.setHeight(maxHeight); 
        }
    }

    /**
     * Return current lineArea or generate a new one if necessary.
     */
    public Area getParentArea(Area childArea) {
        if (lineArea == null) {
            createLine();
        }
        return lineArea;
    }

    private void createLine() {
        lineArea = new LineArea();
        /* Set line IPD from parentArea
         * This accounts for indents. What about first line indent?
         * Should we set an "isFirst" flag on the lineArea to signal
         * that to the parent (Block) LM? That's where indent property
         * information will be managed.
         */
        Area parent = parentLM.getParentArea(lineArea);
        // lineArea.setContentIPD(parent.getContentIPD());
        // remainingIPD = parent.getContentIPD();
        // OR???
        remainingIPD = new MinOptMax(parentLM.getContentIPD());
        this.bFirstLine = false;
    }

    /**
     * Called by child LayoutManager when it has filled one of its areas.
     * See if the area will fit in the current container.
     * If so, add it.
     * This should also handle floats if childArea is an anchor.
     * @param childArea the area to add: should be an InlineArea subclass!
     */
    public void addChild(Area childArea) {
        if ((childArea instanceof InlineArea) == false) {
            // SIGNAL AN ERROR!!!
            return;
        }
        InlineArea inlineArea = (InlineArea) childArea;
        if (lineArea == null) {
            createLine();
        }
        if (inlineArea.getAllocationIPD().min < remainingIPD.max) {
            lineArea.addInlineArea(inlineArea);
            remainingIPD.subtract(inlineArea.getAllocationIPD());
            // Calculate number of spaces
            // Forced line break after this area (ex. ends with LF in nowrap)
            /* NOTYET!
            if (inlineArea.breakAfter()) {
                flush();
            }
             */
            /* Check if line could end after this area (potential line-break
             * character. If not, it must be joined with following inline
             * area to make a word. Otherwise, if the line could break here
             * and if it is "full", add it to the parent area.
             */
            if (remainingIPD.min <= 0) {
                flush();
            }
        }
        else {
            /* The inline area won't entirely fit in this line. Ask its
             * layout manager to split it (by hyphenation for example),
             * in order to fit part of it in the line.
             * Note: only the current child LM could have generated this
             * area, so we ask it to do the split.
             */
            SplitContext splitContext = new SplitContext(remainingIPD);
            if (curLM.splitArea(inlineArea, splitContext)) {
                // inlineArea should now fit
                lineArea.addInlineArea(inlineArea);
            flush(); 
            addChild(splitContext.nextArea);
            } else {
                lineArea.addInlineArea((InlineArea)splitContext.nextArea);
            remainingIPD.subtract(inlineArea.getAllocationIPD());
            if (remainingIPD.min <= 0) {
                flush();
            }
            }
        }
    }

}
