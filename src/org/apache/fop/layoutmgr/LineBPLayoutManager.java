/*
 * $Id$
 * Copyright (C) 2001 The Apache Software Foundation. All rights reserved.
 * For details on use and redistribution please refer to the
 * LICENSE file included with these sources.
 */

package org.apache.fop.layoutmgr;


import org.apache.fop.fo.FObj;
import org.apache.fop.fo.TextInfo;
import org.apache.fop.fo.PropertyManager;
import org.apache.fop.layout.MarginProps;
import org.apache.fop.traits.BlockProps;
import org.apache.fop.area.Area;
import org.apache.fop.area.LineArea;
import org.apache.fop.area.MinOptMax;
import org.apache.fop.area.inline.InlineArea;
import org.apache.fop.fo.properties.TextAlign;

import org.apache.fop.area.inline.Word;
import org.apache.fop.area.inline.Space;
import org.apache.fop.area.inline.Character;

import java.util.ListIterator;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.ArrayList;


/**
 * BPLayoutManager for lines. It builds one or more lines containing
 * inline areas generated by its sub layout managers.
 */
public class LineBPLayoutManager extends 
     InlineStackingBPLayoutManager {

    /**
     * Private class to store information about inline breaks.
     * Each value holds the start and end indexes into a List of
     * inline break positions.
     */
    private static class LineBreakPosition implements BreakPoss.Position {
        int m_iPos;
	double m_dAdjust; // Percentage to adjust (stretch or shrink)

        LineBreakPosition(int iBreakIndex, double dAdjust) {
            m_iPos = iBreakIndex;
	    m_dAdjust = dAdjust;
        }
    }


    private LineArea m_lineArea; // LineArea currently being filled

    /** Break positions returned by inline content. */
    private Vector m_vecInlineBreaks = new Vector(100);

    private BreakPoss m_prevBP = null; // Last confirmed break position
    private boolean m_bJustify = false; // True if fo:block text-align=JUSTIFY
    private int m_iTextIndent = 0;
    private int m_iIndents = 0;

    private int lineHeight;
    private int lead;
    private int follow;

    public LineBPLayoutManager(FObj fobj, List lms, int lh, int l, int f) {
	//super(fobj, lms.listIterator(), lh, l, f);
	super(fobj, lms.listIterator());
        lineHeight = lh;
        lead = l;
        follow = f;
	init(); // Normally done when started by parent!
    }

    protected void initProperties(PropertyManager propMgr) {
	// super.initProperties(propMgr);
	System.err.println("LineBPLayoutManager.initProperties called");
        MarginProps marginProps = propMgr.getMarginProps();
        m_iIndents = marginProps.startIndent + marginProps.endIndent;
	BlockProps blockProps = propMgr.getBlockProps();
	m_bJustify = (blockProps.textAlign == TextAlign.JUSTIFY);
	m_iTextIndent = blockProps.firstIndent;
    }
    

    /**
     * Call child layout managers to generate content as long as they
     * generate inline areas. If a block-level generating LM is found,
     * finish any line being filled and return to the parent LM.
     */
    public BreakPoss getNextBreakPoss(LayoutContext context,
				      BreakPoss.Position prevLineBP) {
        // Get a break from currently active child LM
        // Set up constraints for inline level managers

        if ((context.flags & LayoutContext.CHECK_REF_AREA) != 0) {
            /* Return a BreakPoss indicating that higher level LM
	     * (page) should check reference area and possibly
	     * create a new one.
	     */
	    return new BreakPoss(this, null, BreakPoss.NEED_IPD);
        }

	BPLayoutManager curLM ;        // currently active LM
	BreakPoss prevBP=null;
        BreakPoss bp=null;           // proposed BreakPoss

	Vector vecPossEnd = new Vector();

	// IPD remaining in line
        MinOptMax availIPD = context.getStackLimit();

	// QUESTION: maybe LayoutContext holds the Properties which
	// come from block-level?

	LayoutContext inlineLC = new LayoutContext(context);

	clearPrevIPD();

        while ((curLM = getChildLM()) != null) {
	    // INITIALIZE LAYOUT CONTEXT FOR CALL TO CHILD LM
	    // First break for the child LM in each of its areas
	    boolean bFirstBPforLM =
		(m_vecInlineBreaks.isEmpty() ||
		 (((BreakPoss)m_vecInlineBreaks.lastElement()).
		  getLayoutManager() != curLM));

	    initChildLC(inlineLC, bp, (bp==null), bFirstBPforLM,
			new SpaceSpecifier(true));

// 	    if (bp == null) {
// 		// Start of a new line area
// 		inlineLC.setFlags(LayoutContext.FIRST_AREA, bFirstBPforLM );
// 		inlineLC.setPendingSpace(new SpaceSpecifier(true));
// 	    }
// 	    else if (bFirstBPforLM) {
// 		// Space-after sequence from previous "area"
// 		inlineLC.setFlags(LayoutContext.FIRST_AREA, true);
// 		inlineLC.setPendingSpace(bp.getTrailingSpace());
// 	    }
// 	    else {
// 		inlineLC.setPendingSpace(null);
// 	    }


            /* If first BP in this line but line is not first in this
             * LM and previous line end decision was not forced (LINEFEED),
             * then set the SUPPRESS_LEADING_SPACE flag.
             */
	    inlineLC.setFlags(LayoutContext.SUPPRESS_LEADING_SPACE,
			      (bp == null && !m_vecInlineBreaks.isEmpty() &&
			       ((BreakPoss)m_vecInlineBreaks.lastElement()).
			       isForcedBreak()==false));

	    // GET NEXT POSSIBLE BREAK FROM CHILD LM
	    prevBP = bp;
            if ((bp = curLM.getNextBreakPoss(inlineLC, null)) != null) {
		// Add any space before and previous content dimension
		MinOptMax prevIPD = updatePrevIPD(bp, prevBP, (prevBP==null),
						  inlineLC.isFirstArea());
		MinOptMax bpDim = MinOptMax.add(bp.getStackingSize(), prevIPD);

		// check if this bp fits in line
		boolean bBreakOK = couldEndLine(bp);
		if (bBreakOK) {
		    /* Add any non-conditional trailing space, assuming we
		     * end the line here. If we can't break here, we just
		     * check if the content fits. */
		    bpDim.add(bp.resolveTrailingSpace(true));
		}
		// TODO: stop if linebreak is forced (NEWLINE)
		// PROBLEM: interaction with wrap which can be set
		// at lower levels!
		System.err.println("BPdim=" + bpDim.opt);

		// Check if proposed area would fit in line
		if (bpDim.min > availIPD.max) {
		    // See if we have already found a potential break
		    if (vecPossEnd.size() > 0) break;

		    // This break position doesn't fit
		    // TODO: If we are in nowrap, we use it as is!
		    if (m_bJustify || m_prevBP == null) {
			// try to find a hyphenation point in the word
			// which spans the queued breaks and the proposed bp
			// Even if not justified, we must try to hyphenate if
			// there is no breakpoint at all up to this point!
			do {
			    bp = findHyphenPoss(m_prevBP, bp);
			} while (bp != null &&
				 (bp.getStackingSize().min > availIPD.max));
			if (bp == null) {
			    // Couldn't find a hyphenation point. The line
			    // will be "short".
			}
			else {
			    m_prevBP = bp;
			}
			// Handle pendingIPD if any. The hyphenation point
			// may be within the "pending" content or after it.
                        /* Make sure child LM are updated concerning the actual
                         * hyphenation BreakPoss for their next call!
                         */
		    }
		    /* If we are not in justified text, we can end the line at
		     * prevBP.
		     */
		    break;
		}
		else {
		    // Add the BP to the list whether or not we can break
		    m_vecInlineBreaks.add(bp);
		    // Handle end of this LM's areas
		    if (bBreakOK) {
			m_prevBP = bp; // Save reference to this BP
			if (bp.isForcedBreak()) {
			    break;
			}
			if (bpDim.max >= availIPD.min) {
			    /* This is a possible line BP (line could be filled)
			     * bpDim.max >= availIPD.min
			     * Keep this as a possible break, depending on 
			     * "cost". We will choose lowest cost.
			     * Cost depends on stretch
			     * (ie, bpDim.opt closes to availIPD.opt), keeps
			     * and hyphenation.
			     */
			    System.err.println("Found potential linebreak");
			    vecPossEnd.add(new BreakCost(bp,
			     Math.abs(availIPD.opt - bpDim.opt )));
			}
			// Otherwise it's short
		    }
		    else { 
			/* Can't end line here. */
		    }
		} // end of bpDim.min <= availIPD.max
	    } // end of getNextBreakPoss!=null on current child LM
	    else {
		/* The child LM can return a null BreakPoss if it has
		 * nothing (more) to layout. This can happen when backing
		 * up. Just try the next child LM.
		 */
	    }
	} // end of while on child LM
	if ((curLM = getChildLM())== null) {
	    // No more content to layout!
	    setFinished(true);
	}

if(bp == null) return null;

	// Choose the best break
	if (!bp.isForcedBreak() && vecPossEnd.size()>0) {
	    m_prevBP = getBestBP(vecPossEnd);
	}
	// Backup child LM if necessary
	if (bp != m_prevBP) {
	    // Remove any pending breaks from the vector
	    while (m_vecInlineBreaks.lastElement()!=m_prevBP) {
		m_vecInlineBreaks.remove(m_vecInlineBreaks.size()-1);
	    }
	    reset(m_prevBP.getLayoutManager(), m_prevBP.getPosition());
	}
	// Distribute space in the line
	MinOptMax actual = MinOptMax.add(m_prevBP.getStackingSize(),
					 getPrevIPD(m_prevBP.getLayoutManager()));
	// ATTENTION: make sure this hasn't gotten start space for next
	// LM added onto it!
	actual.add(m_prevBP.resolveTrailingSpace(true));
	System.err.println("Target opt=" + availIPD.opt + 
			  " bp.opt=" + actual.opt + " bp.max=" + actual.max
			   + " bm.min=" + actual.min);

	// Don't justify last line in the sequence or if forced line-end
	boolean bJustify = (m_bJustify && !m_prevBP.isForcedBreak() &&
			    !isFinished());
        return makeLineBreak(m_prevBP, availIPD, actual, bJustify);
    }

    protected boolean couldEndLine(BreakPoss bp) {
	if (bp.canBreakAfter()) {
	    return true; // no keep, ends on break char
	}
	else if (bp.isSuppressible()) {
	    // NOTE: except at end of content for this LM!!
	    // Never break after only space chars or any other sequence
	    // of areas which would be suppressed at the end of the line.
	    return false; 
	}
	else {
	    // See if could break before next area
	    // TODO: do we need to set anything on the layout context?
	    LayoutContext lc=new LayoutContext(0);
	    BPLayoutManager nextLM = getChildLM();
	    return (nextLM == null || 
		    nextLM.canBreakBefore(lc));
	}
    }


    private BreakPoss getBestBP(Vector vecPossEnd) {
	if (vecPossEnd.size()==1) {
	    return ((BreakCost)vecPossEnd.elementAt(0)).getBP();
	}
	// Choose the best break (use a sort on cost!)
	Iterator iter = vecPossEnd.iterator();
	int minCost= Integer.MAX_VALUE;
	BreakPoss bestBP = null;
	while (iter.hasNext()) {
	    BreakCost bc = (BreakCost)iter.next();
	    if (bc.getCost() < minCost) {
		minCost = bc.getCost();
		bestBP = bc.getBP();
	    }
	}
	return bestBP;
    }

    /** Line area is always considered to act as a fence. */
    protected boolean hasLeadingFence(boolean bNotFirst) {
	return true;
    }
    
    /** Line area is always considered to act as a fence. */
    protected boolean hasTrailingFence(boolean bNotLast) {
	return true;
    }
    


    private BreakPoss findHyphenPoss(BreakPoss prevBP, BreakPoss newBP) {
	// Get a "word" to hyphenate by getting characters from all
	// pending break poss which are in m_vecInlineBreaks, starting
	// with the position just AFTER prevBP.getPosition()
	return null;
    }

    private BreakPoss makeLineBreak(BreakPoss inlineBP, MinOptMax target,
				    MinOptMax actual, boolean bJustify) {
        // make a new BP
	// Store information needed to make areas in the LineBreakPosition!
	// Calculate stretch or shrink factor

	double dAdjust=0.0;
	if (bJustify) {
	    if (actual.opt < target.opt) {
		// Stretch
		dAdjust = (double)(target.opt - actual.opt)/
		    (double)(actual.max - actual.opt);
	    }
	    else {
		// Shrink
		dAdjust = (double)(target.opt - actual.opt)/
		    (double)( actual.opt - actual.min);
	    }
	}
	System.err.println("Adjustment factor=" + dAdjust);
        BreakPoss curLineBP =
            new BreakPoss(this,
			  new LineBreakPosition(m_vecInlineBreaks.size()-1,
			  dAdjust));

	/* FIX ME!! 
	 * Need to calculate line height based on all inline BP info
	 * for this line not just the current inlineBP!
	 */
	curLineBP.setFlag(BreakPoss.ISLAST, isFinished());
	curLineBP.setStackingSize(inlineBP.getNonStackingSize());
        return curLineBP;
    }


    // Generate and add areas to parent area
    // Set size etc
    public void addAreas(PositionIterator parentIter) {
	BPLayoutManager childLM ;
	int iStartPos = 0;
	while  (parentIter.hasNext()) {
	    LineBreakPosition lbp  = (LineBreakPosition)parentIter.next();
	    System.err.println("lbp.endpos=" + lbp.m_iPos);
	    m_lineArea = new LineArea();
	    // Add the inline areas to lineArea
	    PositionIterator inlinePosIter =
		new BreakPossPosIter(m_vecInlineBreaks,
				     iStartPos, lbp.m_iPos+1);
	    iStartPos = lbp.m_iPos+1;
	    while  ((childLM = inlinePosIter.getNextChildLM())!= null) {
		childLM.addAreas(inlinePosIter);
	    }
	    m_lineArea.verticalAlign(lineHeight, lead, follow);
	    parentLM.addChild(m_lineArea);
	}
	m_lineArea = null;
    }

    public boolean addChild(Area childArea) {
	// Make sure childArea is inline area
	if (childArea instanceof InlineArea) {
	    m_lineArea.addInlineArea((InlineArea)childArea);
	}
	return false;
    }

    // NOTE: PATCHED FOR NOW TO ADD BreakPoss stuff to Kerion's changes
    public boolean generateAreas() {
	// Make break positions and return lines!
	// Set up a LayoutContext
	int ipd = 0;
	BreakPoss bp;
	Vector vecBreakPoss = new Vector(20);

	// Force area creation on first call
	// NOTE: normally not necessary when fully integrated!
	LayoutContext childLC = new LayoutContext(LayoutContext.CHECK_REF_AREA);

	while (!isFinished()) {
	    if ((bp = getNextBreakPoss(childLC, null)) != null) {
		if (bp.checkIPD()) {
		    // Need IPD in order to layout lines!
		    // This is supposed to bubble up to PageLM to
		    // make the necessary flow reference area, depending
		    // on span and break-before flags set as the BreakPoss
		    // makes its way back up the call stack.
		    // Fake it for now!
		    parentLM.getParentArea(null);
		    ipd = parentLM.getContentIPD();
		    childLC.flags &= ~LayoutContext.CHECK_REF_AREA;
		    childLC.setStackLimit(new MinOptMax(ipd - m_iIndents -
						       m_iTextIndent));
		}
		else {
		    vecBreakPoss.add(bp);
		    // Reset stackLimit for non-first lines
		    childLC.setStackLimit(new MinOptMax(ipd - m_iIndents));
		}
	    }
        }
	addAreas(new BreakPossPosIter(vecBreakPoss, 0, vecBreakPoss.size()));
        return false;
    }


}

